## 次优查找树（Nearly Optimal Search Tree）构造方法详解

次优查找树是在静态查找表中提高查找效率的一种二叉树构造方法，它在无法构建最优查找树（时间复杂度高）时的近似解法。

### 一、基本概念

1. **PH值**：带权路径长度（Weighted Path Length）
   ```
   PH = Σ(权值ᵢ × 深度ᵢ)
   ```
   - 权值：查找频率或概率
   - 深度：根结点深度为1，每下一层深度+1
   - PH值越小，查找效率越高

2. **次优查找树的目标**：
   - 不是绝对最优（最优查找树构造复杂）
   - 而是"次优"：近似最优，构造简单

### 二、构造算法步骤

#### 步骤1：准备数据
- 有序关键字序列：K₁, K₂, ..., Kₙ
- 对应权值：W₁, W₂, ..., Wₙ
- 计算累计权值：SW[i] = W₁ + W₂ + ... + Wᵢ

#### 步骤2：选择根结点
对于区间[i, j]的关键字，选择根结点Kₖ使得：
```
|(SW[k-1] - SW[i-1]) - (SW[j] - SW[k])| 最小
```
即：**左子树累计权值和与右子树累计权值和的差值绝对值最小**

#### 步骤3：递归构造
- 对左子树区间[i, k-1]重复步骤2
- 对右子树区间[k+1, j]重复步骤2

### 三、以题目为例详细构造

#### 初始数据：
```
关键字: A  B  C  D  E  F  G  H  I  J  K  L
权值:   8  2  3  4  9  3  2  6  7  1  1  4
下标:   1  2  3  4  5  6  7  8  9  10 11 12
```

#### 第一步：计算累计权值SW
```
SW[0] = 0
SW[1] = 8 (A)
SW[2] = 10 (A+B)
SW[3] = 13 (A+B+C)
SW[4] = 17 (A+B+C+D)
SW[5] = 26 (A+B+C+D+E)
SW[6] = 29 (A+B+C+D+E+F)
SW[7] = 31 (A+B+C+D+E+F+G)
SW[8] = 37 (A+B+C+D+E+F+G+H)
SW[9] = 44 (A+B+C+D+E+F+G+H+I)
SW[10]= 45 (A+B+C+D+E+F+G+H+I+J)
SW[11]= 46 (A+B+C+D+E+F+G+H+I+J+K)
SW[12]= 50 (A+B+C+D+E+F+G+H+I+J+K+L)
```

#### 第二步：选择整棵树根结点（区间[1,12]）
对于每个位置k，计算：
```
Δ = |左子树权值和 - 右子树权值和|
  = |(SW[k-1] - SW[0]) - (SW[12] - SW[k])|
```

计算示例：
- k=6(F)：Δ = |(SW[5]-0) - (50-SW[6])| = |26 - 21| = 5 ✓ 最小
- k=5(E)：Δ = |17 - (50-26)| = |17 - 24| = 7
- k=7(G)：Δ = |29 - (50-31)| = |29 - 19| = 10

所以**根结点是F**

#### 第三步：构造F的左子树（区间[1,5]：A-E）
计算区间[1,5]：
- k=3(C)：Δ = |(SW[2]-0) - (SW[5]-SW[3])| = |10 - (26-13)| = |10-13| = 3 ✓ 最小
所以左子树根是C

#### 第四步：构造F的右子树（区间[7,12]：G-L）
计算区间[7,12]：
- k=9(I)：Δ = |(SW[8]-SW[6]) - (SW[12]-SW[9])| = |(37-29) - (50-44)| = |8-6| = 2 ✓ 最小
所以右子树根是I

#### 第五步：继续递归...
一直递归直到所有区间处理完毕。

## 第五步：继续递归（详细展开）

### 当前状态：
```
根：F(6)  [区间1-12]
左子树：C(3) [区间1-5]  
右子树：I(9) [区间7-12]
```

### 1. 处理C的左子树（区间[1,2]：A,B）

**计算区间[1,2]**：
- k=1(A)：Δ = |(SW[0]-SW[0]) - (SW[2]-SW[1])| = |0 - (10-8)| = |0-2| = 2
- k=2(B)：Δ = |(SW[1]-SW[0]) - (SW[2]-SW[2])| = |8 - 0| = 8

**最小Δ=2**，所以根结点是**A**

**A的左子树**：区间[空]，返回NULL
**A的右子树**：区间[2,2]，只有一个结点B

**结果**：
```
A(1)
 \
 B(2)
```

### 2. 处理C的右子树（区间[4,5]：D,E）

**计算区间[4,5]**：
- k=4(D)：Δ = |(SW[3]-SW[3]) - (SW[5]-SW[4])| = |0 - (26-17)| = |0-9| = 9
- k=5(E)：Δ = |(SW[4]-SW[3]) - (SW[5]-SW[5])| = |(17-13) - 0| = |4-0| = 4

**最小Δ=4**，所以根结点是**E**

**E的左子树**：区间[4,4]，只有一个结点D
**E的右子树**：区间[空]，返回NULL

**结果**：
```
E(5)
 /
D(4)
```

### 3. 处理I的左子树（区间[7,8]：G,H）

**计算区间[7,8]**：
- k=7(G)：Δ = |(SW[6]-SW[6]) - (SW[8]-SW[7])| = |0 - (37-31)| = |0-6| = 6
- k=8(H)：Δ = |(SW[7]-SW[6]) - (SW[8]-SW[8])| = |(31-29) - 0| = |2-0| = 2

**最小Δ=2**，所以根结点是**H**

**H的左子树**：区间[7,7]，只有一个结点G
**H的右子树**：区间[空]，返回NULL

**结果**：
```
H(8)
 /
G(7)
```

### 4. 处理I的右子树（区间[10,12]：J,K,L）

**计算区间[10,12]**：
- k=10(J)：Δ = |(SW[9]-SW[9]) - (SW[12]-SW[10])| = |0 - (50-45)| = |0-5| = 5
- k=11(K)：Δ = |(SW[10]-SW[9]) - (SW[12]-SW[11])| = |(45-44) - (50-46)| = |1-4| = 3
- k=12(L)：Δ = |(SW[11]-SW[9]) - (SW[12]-SW[12])| = |(46-44) - 0| = |2-0| = 2

**最小Δ=2**，所以根结点是**L**

**L的左子树**：区间[10,11]：J,K
**L的右子树**：区间[空]，返回NULL

### 5. 处理L的左子树（区间[10,11]：J,K）

**计算区间[10,11]**：
- k=10(J)：Δ = |(SW[9]-SW[9]) - (SW[11]-SW[10])| = |0 - (46-45)| = |0-1| = 1
- k=11(K)：Δ = |(SW[10]-SW[9]) - (SW[11]-SW[11])| = |(45-44) - 0| = |1-0| = 1

**两者Δ相同=1**，可以任选，这里选**J**（按题目结果）

**J的左子树**：区间[空]，返回NULL
**J的右子树**：区间[11,11]，只有一个结点K

**结果**：
```
J(10)
 \
 K(11)
```

## 完整的递归构造过程总结：

```
第1层：整个区间[1,12] → 根：F(6)

第2层：
  - F左子树区间[1,5] → 根：C(3)
  - F右子树区间[7,12] → 根：I(9)

第3层：
  - C左子树区间[1,2] → 根：A(1)
  - C右子树区间[4,5] → 根：E(5)
  - I左子树区间[7,8] → 根：H(8)
  - I右子树区间[10,12] → 根：L(12)

第4层：
  - A右子树区间[2,2] → 只有B(2)
  - E左子树区间[4,4] → 只有D(4)
  - H左子树区间[7,7] → 只有G(7)
  - L左子树区间[10,11] → 根：J(10)

第5层：
  - J右子树区间[11,11] → 只有K(11)
```

## 叶结点确定的关键点：

### 1. **区间长度为1时**：
当一个区间只有一个结点时，它自然成为叶结点（或只有一个孩子的结点）
- 如区间[2,2]：只有B，作为A的右孩子
- 如区间[4,4]：只有D，作为E的左孩子

### 2. **区间长度为0时**：
返回NULL，表示空子树
- 如A的左子树区间[空]
- 如E的右子树区间[空]

### 3. **递归终止条件**：
```c
if (区间开始 > 区间结束) 
    return NULL;  // 空子树
if (区间开始 == 区间结束) 
    return 创建结点(关键字[开始]);  // 叶结点
```

### 4. **构建叶结点时的左右子树**：
对于叶结点（区间长度为1）：
- **左子树**：区间[i,i-1] → 空
- **右子树**：区间[i+1,i] → 空
- 所以**真正的叶结点没有孩子**

但在题目中：
- B是A的右孩子，但B自己可能还有子树吗？没有，因为区间[2,2]处理完毕
- 实际上，在最终的树中，B、D、G、K都是叶结点（没有孩子）

## 最终树结构的正确理解：

```
        F(3)
       /     \
     C(3)     I(7)
    /   \     /   \
  A(8) E(9) H(6) L(4)
   \    /    /    /
   B(2)D(4)G(2) J(1)
                \
                K(1)
```

**真正的叶结点**：B, D, G, K（度为0）
**只有一个孩子的结点**：A, E, H, J（度为1）
**有两个孩子的结点**：C, I, L, F（度为2）

这就是完整的递归构造过程！每个步骤都严格遵循"选择使左右子树权值差最小的结点作为根"的原则。

### 四、最终树的PH值计算

根据给出的树结构：
```
F(3)[1]          深度1×权值3 = 3
C(3)[2]          深度2×权值3 = 6
I(7)[2]          深度2×权值7 = 14
A(8)[3]          深度3×权值8 = 24
E(9)[3]          深度3×权值9 = 27
H(6)[3]          深度3×权值6 = 18
L(4)[3]          深度3×权值4 = 12
B(2)[4]          深度4×权值2 = 8
D(4)[4]          深度4×权值4 = 16
G(2)[4]          深度4×权值2 = 8
J(1)[4]          深度4×权值1 = 4
K(1)[5]          深度5×权值1 = 5

总PH = 3+6+14+24+27+18+12+8+16+8+4+5 = 145
```

### 五、算法特点

1. **时间复杂度**：O(n²)，比最优查找树的O(n³)简单
2. **空间复杂度**：O(n)
3. **优点**：
   - 构造相对简单
   - 查找效率接近最优
   - 适用于静态查找表
4. **缺点**：
   - 不是绝对最优
   - 需要预先知道权值分布

### 六、应用场景

1. 编译器中符号表管理
2. 数据库索引的静态构造
3. 字典的静态存储
4. 任何需要高效静态查找的场合

这就是次优查找树的完整构造方法！
