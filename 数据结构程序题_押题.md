# 考题预测——用了一学期的DeepSeek
根据您提供的全部作业题，以及考试将**从这些题目中选择原题**、且**模拟题涉及的3道题目**会考的信息，我来预测最可能考察的题目：

## 一、**必考题（模拟题原题）**

这三道题**100%会考**，因为已经明确标注：

1. **顺序表插入函数** `insertPost_seq`（第一题）
2. **二叉树叶子结点计算** `num_of_leaves`（第十七题的第2部分）
3. **树的广度优先遍历** `bfsOrder`（第十八题的第3部分）

## 二、**高概率考题（重点掌握）**

以下题目有**很高概率**被选中：

### 1. **链表操作类**（7/10题）
- **打印单链表** `printList_link`（第六题）
- **链表插入** `insertPre_link`（第八题）
- **链表删除** `deleteV_link`（第九题）
- **求链表长度** `length_link`（第七题）*（已标注预测）*

### 2. **二叉树操作类**（5/7题）
- **先序/中序/后序遍历**（第十六题）
- **计算结点总数** `num_of_nodes`（第十七题第1部分）
- **计算二叉树高度** `depth`（第十七题第3部分）

### 3. **栈和队列基础**（4/4题）
- **栈的创建** `createEmptyStack_seq`（第十三题）
- **队列的创建** `createEmptyQueue_seq`（第十四题）
- **十进制转二进制** `tr`（第十二题）

## 三、**预测分析表**

| 题型 | 预测题目 | 难度 | 考察频率 | 备考建议 |
|------|----------|------|----------|----------|
| **顺序表** | 插入、删除、反转 | ★★☆ | 高频 | 必须掌握移动元素操作 |
| **链表** | 插入、删除、长度 | ★★★ | 高频 | 重点掌握指针操作 |
| **二叉树** | 遍历、叶子计数、高度 | ★★★ | 高频 | 递归算法必须熟练 |
| **树** | 三种遍历方式 | ★★☆ | 中频 | 广度优先是重点 |
| **栈/队列** | 创建、应用 | ★★☆ | 中频 | 基础操作要熟悉 |
| **字符串** | 子串删除 | ★★★ | 低频 | 了解即可 |

## 四、**最可能出现的组合**

### **组合A（侧重线性结构）**
1. 顺序表插入/删除（第一/二题）
2. 链表插入/删除（第八/九题）  
3. 树的广度优先遍历（第十八题）

### **组合B（侧重树结构）**
1. 二叉树叶子结点计算（第十七题）
2. 二叉树遍历（第十六题）
3. 树的广度优先遍历（第十八题）

### **组合C（综合考察）**
1. 链表操作（第六/七题）
2. 二叉树操作（第十七题）
3. 栈应用（第十二题）

## 五、**备考建议**

### **必须100%掌握的：**
1. **三个模拟题原题**：要能默写
2. **链表基本操作**：插入、删除、遍历
3. **二叉树递归遍历**：前中后序
4. **树的广度优先**：队列实现

### **重点理解的核心：**
1. **指针操作**：链表的核心
2. **递归思想**：树算法的核心  
3. **数组移动**：顺序表操作的关键
4. **队列应用**：广度优先的基础

### **时间分配建议：**
- 30%时间：三个必考题（确保满分）
- 40%时间：链表和二叉树（高频考点）
- 20%时间：栈和队列（基础题）
- 10%时间：字符串和树遍历（了解即可）

## 六、**考场策略**

1. **先做模拟题原题**：确保拿到这15分
2. **再做链表二叉树题**：这是主要分数来源
3. **最后做栈队列题**：基础分要拿到
4. **检查边界条件**：空表、空树、越界等
5. **注释要清晰**：有助于老师给分

**总结**：重点准备**链表操作**、**二叉树递归**和**树的广度优先**，这三类题目覆盖了80%以上的考点。三个模拟题原题必须滚瓜烂熟！

# 作业题原题整理——24级信管郭鹏飞
## 顺序表 SeqList
```C
/* ----------------------顺序表---------------------- */
typedef int DataType;

struct SeqList {
    int MAXNUM;
    int      n;         /* 存放线性表中元素的个数 n < MAXNUM */
    DataType *element;  /* 存放线性表中的元素 */
};

typedef struct SeqList SeqList, *PSeqList;

//模拟题原题
//一、试写一个插入函数 InsertPost_seq(palist, p, x)，在 palist 所指的顺序表中，下标为 p 的元素之后，插入一个值为 x 的元素，返回成功与否的标志
int insertPost_seq(PSeqList palist, int p, DataType x) {
    /*在下标为p的元素之后，插入一个值为x的元素*/
    int q;
    if (palist->n >= palist->MAXNUM) { /* 溢出检查 */
        printf("Overflow!\n");
        return 0;
    }
    if (isNullList_seq(palist)) { /* 空表处理 */
        palist->element[0] = x;
        palist->n = 1;
        return 1;
    }
    if (p < -1 || p >= palist->n) {
        printf("Not exist! \n");
        return 0;
    }
    // 元素移动范围从p+1开始（原p位置元素无需移动）
    for (q = palist->n - 1; q > p; q--) { 
        palist->element[q + 1] = palist->element[q];
    }
    palist->element[p + 1] = x; /* 在p位置后插入元素 */
    palist->n = palist->n + 1;
    return 1;
}

//二、写一个删除算法 deleteV_seq(palist, x)，在 palist 所指的顺序表中，删除值为 x 的元素，返回成功与否的标志
int deleteV_seq(PSeqList palist, DataType x) {
    /* 在palist所指顺序表中删除第一个值为x的元素 */
    int q = locate_seq(palist, x);
    if (q == -1) {  // 元素x不存在
        printf("Element %d not found!\n", x);
        return 0;
    }
    return deleteP_seq(palist, q);  // 删除下标为q的元素
}

int  deleteP_seq(PSeqList palist, int p){
    /* 在palist所指顺序表中删除下标为ｐ的元素 */
    int q;
    if (p < 0  || p > palist->n - 1){
        printf("Not exist!\n");
        return  (0);
    }
    for(q = p; q < palist->n - 1; q++)  /* 被删除元素之后的元素均前移一个位置 */
        palist->element[q] = palist->element[q+1];
    palist->n = palist->n - 1;          /* 元素个数减1 */
    return ( 1 );
}

//三、设有一线性表 e = (e1,e2,……,en)，其逆线性表为(en,……,e2,e1)，设计一算法，将顺序表表示成顺序表的逆
int reverseList_seq(PSeqList palist){
    /*反转线性表元素*/
    if (palist == NULL || isNullList_seq(palist))
        return 0;
    int i = 0;
    int j = palist->n - 1;
    DataType temp;

    while (i < j) {
        temp = palist->element[i];
        palist->element[i] = palist->element[j];
        palist->element[j] = temp;
        i++;
        j--;
    }
    return 1;

    //参考：C 数组反转
    // int i,j,m=(n-1)/2;
    // for(i=0;i<=m;i++)
    // {   j=n-1-i;
    //     temp=x[i]; x[i]=x[j]; x[j]=temp;
    // }
}

//四、已知长度为 n 的线性表为顺序存储，写一个算法，求出线性表中最小元素
DataType minElement_seq(PSeqList palist) {
    /* 查找顺序表中的最小元素，返回最小元素值；空表返回-1 */
    if (isNullList_seq(palist)) {
        printf("Error: Empty list!\n");
        return -1;
    }
    
    DataType min_val = palist->element[0];  // 初始化为第一个元素
    for (int i = 1; i < palist->n; i++) {   // 遍历
        if (palist->element[i] < min_val) {
            min_val = palist->element[i];   // 更新最小值
        }
    }
    return min_val;
}

//五、已知线性表长度为 n，采用顺序存储，写出一算法，删除所有值为 x 的元素
int deleteAllX_seq(PSeqList palist, DataType x) {
/* 删除顺序表中所有值为x的元素 */   
    if (isNullList_seq(palist)) {
        return 1;  // 空表无需删除，返回成功
    }
    
    int i = 0;

    for (int j = 0; j < palist->n; j++) {
        if (palist->element[j] != x) {
            palist->element[i] = palist->element[j];
            i++;
        }
    }
    
    palist->n = i;
    return 1;
}
```

## 链表
### 打印单链表 printList_link（第六题）
### 链表插入 insertPre_link（第八题）
### 链表删除 deleteV_link（第九题）
### 求链表长度 length_link（第七题）（已标注预测）
```C
/* ----------------------链表---------------------- */

typedef int DataType;

struct Node;					  /* 单链表结点类型 */
typedef struct Node  *PNode;	  /* 结点指针类型 */
typedef struct Node  *LinkList;  /* 单链表类型 */

struct  Node { 					  /* 单链表结点结构 */
    DataType  info;
    PNode     link;
};

LinkList llist;   //一个链表头指针

//六、编写打印单链表中所有数据的函数
void printList_link(LinkList llist){
/* 打印单链表中所有结点的值 */
    if (llist == NULL) {
        printf("Not exist!\n");
        return;
    }

    PNode p = llist->link;   // 跳过头结点
    if (p == NULL) {
        printf("Empty list!\n");
        return;
    }

    while (p != NULL) {
        printf("%d ", p->info);
        p = p->link;
    }
    printf("\n");
}

//七、求线性表中元素个数的函数
int length_link(LinkList llist){
/* 求链表中元素个数 */
    if (llist == NULL) return 0;

    int c = 0;
    PNode p = llist->link;   // 跳过头结点
    while (p != NULL) {
        c++;
        p = p->link;
    }
    return c;
}

//模拟题原题
//八、写一函数，在带头节点的单链表 llist 中，p 指向的结点前边插入值为 x 的新结点，返回成功与否的标志
int insertPre_link(LinkList llist, PNode p, DataType x){
    /* 在带头结点的单链表llist中，在p所指结点之前插入值为x的新结点 */
    
    // 1. 参数检查
    if (llist == NULL || p == NULL) {
        printf("链表或目标结点不存在！\n");
        return 0;
    }
    
    // 2. 查找p的前驱结点
    PNode pre = locatePre_link(llist, p);
    
    // 3. 如果找不到前驱（p不在链表中）
    if (pre == NULL) {
        printf("未找到前驱结点！\n");
        return 0;
    }
    
    // 4. 创建新结点
    PNode q = (PNode)malloc(sizeof(struct Node));
    if (q == NULL) {
        printf("内存分配失败！\n");
        return 0;
    }
    
    // 5. 插入新结点
    q->info = x;
    q->link = pre->link;  // q指向p
    pre->link = q;        // pre指向q
    
    return 1;
}

int insertPre_link(LinkList llist, DataType value, DataType x){
/* 在带头结点的单链表 llist 中，在值为 value 的结点之前插入值为 x 的新结点 */
    if (llist == NULL) {  
        printf("链表不存在！\n");
        return 0;
    }
    PNode p = locate_link(llist, value);	// 找到值为 value 的结点位置
    if (p == NULL) {
        printf("未找到值为 %d 的结点！\n", value);
        return 0;
    }
    PNode pre = locatePre_link(llist, p);   // 找到前驱
    if (pre == NULL) {
        printf("未找到前驱！\n");
        return 0;
    }
    PNode q = (PNode)malloc(sizeof(struct Node));    // 申请新结点
    if (q == NULL) {
        printf("Out of Space!\n");  
        return 0;
    }

    q->info = x;
    q->link = pre->link;
    pre->link = q;
    return 1;
}


int insertPost_link(LinkList llist, PNode p, DataType x) {
/* 在带头结点的单链表 llist 中，在 p 所指结点之后插入值为 x 的新结点 */
    PNode q = (PNode)malloc(sizeof(struct Node));	/*申请新结点*/ 
    if (q == NULL) {
        printf("Out of Space!\n");  
        return 0;
    }
    q->info = x;
    q->link = p->link;
    p->link = q;
    return 1;
}

//九、写一函数，在带头结点的单链表 llist 中，删除 p 指向的节点，返回成功的标志
int deleteNode_link(LinkList llist, PNode p){
/* 在带头结点的单链表 llist 中删除 p 所指结点 */
    if (llist == NULL || p == NULL || llist->link == NULL) {
        printf("链表为空或结点不存在！\n");
        return 0;
    }

    PNode pre = locatePre_link(llist, p);
    if (pre == NULL) {
        printf("未找到前驱结点！\n");
        return 0;
    }

    pre->link = p->link;
    free(p);
    return 1;
}

int deleteV_link(LinkList llist, DataType x){
/* 在带头结点的单链表 llist 中删除第一个元素值为 x 的结点 */ 
    PNode p, q;	
    p = llist;
    if(p==NULL) return 0 ;
    while( p->link != NULL && p->link->info != x )
        p = p->link;	/*找值为x的结点的前驱结点的存储位置 */     
    if( p->link == NULL ) {	/* 没找到值为x的结点 */
        printf("Not exist!\n ");	
        return 0 ;
    }
    else {
        q = p->link;	//p的后继
        p->link = q->link;	//p的后继的后继
        free(q);
        return 1;
    } 

}

//十、已知 llist 为带头结点的单链表，删除下标为 i 的结点的算法
int deleteIndex_link(LinkList llist, int i){
/* 删除带头结点的单链表 llist 中下标为 i 的结点 */
    if (llist == NULL || i < 0) {
        printf("链表为空或下标不合法！\n");
        return 0;
    }

    PNode pre = llist;       // 前驱结点，从头结点开始
    PNode p = llist->link;   // 当前结点，跳过头结点
    int index = 0;

    // 遍历找到下标为 i 的结点
    while (p != NULL && index < i) {
        pre = p;
        p = p->link;
        index++;
    }

    if (p == NULL) {
        printf("下标 %d 超出链表长度！\n", i);
        return 0;
    }

    // 删除结点
    pre->link = p->link;
    free(p);

    return 1;
}

//预测-求链表元素个数
int length_link(LinkList llist){
/* 求链表中元素个数 */
    if (llist == NULL) return 0;

    int c = 0;
    PNode p = llist->link;   // 跳过头结点
    while (p != NULL) {
        c++;
        p = p->link;
    }
    return c;
}
```

## 字符串
```C
/* ----------------------字符串---------------------- */

struct SeqString { 		/* 顺序串的类型 */
    int   n;			/*串的长度n<MAXNUM */
    char  c[MAXNUM];
};
 
typedef struct SeqString *PSeqString;

//十一、设有一个长度为 s 的字符串采用顺序存储，现要求从此串的第 m 个字符开始删除长度为 t 的子串，m < s, t < (s - m).请写完成该功能的函数
void deleteSubStr_seq(PSeqString s, int m, int t) {
    // 参数合法性检查
    if (s == NULL) {
        printf("串不存在！\n");
        return;
    }
    if (m <= 0 || m > s->n || t < 0) {
        printf("删除位置或长度不合法！\n");
        return;
    }
    if (t > s->n - m + 1) {
        t = s->n - m + 1;
    }

    // 将后面的字符前移
    for (int i = m - 1; i + t < s->n; i++) {
        s->c[2] = s->c[2 + 2];
        s->c[3] = s->c[3 + 2];
        s->c[i] = s->c[i + t];
    }

    // 更新长度
    s->n = s->n - t;
}

/* 求从s所指的顺序串中第i(i>0)个字符开始连续取j个字符所构成的子串 */
PSeqString subStr_seq(PSeqString s,int i,int j) {
    int k;
    PSeqString s1 = createNullStr_seq( );	 /* 创建一空串 */
    if (s1==NULL) return (NULL);
    if ( i > 0 && i <= s->n && j > 0 ) {
        if ( s->n < i + j - 1 )  j = s->n - i + 1; /*若从i开始取不了j个字符,则能取几个就取几个*/ 
        for (k = 0; k < j; k++)
            s1->c[k] = s->c[i + k - 1];
        s1->n = j;
    }
    return s1;
}
```

## 栈（顺序）
### 栈的创建 createEmptyStack_seq（第十三题）
### 十进制转二进制 tr（第十二题）
```C
/* ----------------------栈（顺序）---------------------- */

typedef int DataType; /* 栈中元素类型，应根据需要定义 */

struct SeqStack {	  /* 顺序栈类型定义 */
    int  t; 		  /* 栈顶位置指示 */
    DataType  s[MAXNUM];
};

typedef struct SeqStack SeqSack, *PSeqStack;	

//十二、编写一个算法，对于输入的十进制非负整数，将它的二进制表示打印出来
void tr(int d){
    PSeqStack stack = createEmptyStack_seq();
    int num = d;
    
    // 处理0的特殊情况
    if (num == 0) {
        printf("十进制 0 的二进制表示为: 0\n");
        free(stack);
        return;
    }
    
    // 处理负数
    int isNegative = 0;
    if (num < 0) {
        isNegative = 1;
        num = -num;
    }
    
    // 将二进制位压入栈中
    while (num > 0) {
        int r = num % 2;
        push_seq(stack, r);
        num = num / 2;
    }

     // 输出结果
    printf("十进制 %d 的二进制表示为: ", d);
    if (isNegative) {
        printf("-");
    }
    
    // 从栈中弹出并输出二进制位
    while (!isEmptyStack_seq(stack)) {
        printf("%d", top_seq(stack));
        pop_seq(stack);
    }
    printf("\n");
    
    free(stack);
}

//十三、写一个算法：PSeqStack  createEmptyStack_seq(int m)
PSeqStack  createEmptyStack_seq(  ){
    PSeqStack pastack = (PSeqStack)malloc(sizeof(struct SeqStack));
    if (pastack==NULL)
        printf("Out of space!! \n");
    else
        pastack->t = -1;
    return pastack;
}
```

## 队列
### 队列的创建 createEmptyQueue_seq（第十四题）
```C
/* ----------------------队列（顺序）---------------------- */

typedef int DataType; 
struct  SeqQueue {	/* 顺序队列类型定义 */
    int f, r;
    DataType q[MAXNUM];
};

typedef struct SeqQueue SeqQueue, *PSeqQueue;	/* 顺序队列类型和指针类型 */

//十四、写出创建空队列的函数(顺序存储)、打印队列数据的函数。
PSeqQueue createEmptyQueue_seq( void ){ 
    PSeqQueue paqu = (PSeqQueue)malloc(sizeof(struct SeqQueue));
    if (paqu==NULL)
        printf("Out of space!! \n");
    else
        paqu->f = paqu->r = 0;
    return paqu;
}
```

## 二叉树（顺序）
```C
/* ----------------------二叉树（顺序）---------------------- */

#define MAXNODE 20
typedef int DataType;
struct SeqBTree	{ 			/* 顺序树类型定义 */
    int       n;			/* 改造成完全二叉树后，结点的个数 */
    DataType  nodelist[MAXNODE];
};

typedef struct SeqBTree *PSeqBTree;

//十五、二叉树顺序存储中:
    /*
    1. 写出创建空二又树的函数
    2. 完成主函数，实现建立如下二叉树,并输出其先根周游的结果。
    */
PSeqBTree createEmptyBTree_seq(){
    PSeqBTree t = (PSeqBTree)malloc(sizeof(struct SeqBTree));
    if (t != NULL)
    {
        t->n = 0;  // 初始节点数为0
        for (int i = 0; i < MAXNODE; i++){
            t->nodelist[i] = '@';  // 用 @ 表示空位置
        }
    }
    return t;
}

/* 先根周游的递归函数 */
void preOrder_seq(PSeqBTree t, int p) {
    if (p >= t->n || t->nodelist[p] == '@')
        return;  // 超出范围或空节点则返回
    
    // 访问根节点
    printf("%c ", t->nodelist[p]);
    
    // 递归遍历左子树
    preOrder_seq(t, 2*p + 1);
    
    // 递归遍历右子树
    preOrder_seq(t, 2*p + 2);
}
```

## 二叉树（链接）
### 先序/中序/后序遍历（第十六题）
### 计算结点总数 num_of_nodes（第十七题第1部分）
### 计算二叉树高度 depth（第十七题第3部分）
```C
/* ----------------------二叉树（链接）---------------------- */

typedef char DataType;

struct BinTreeNode;                         /* 二叉树中结点 */
typedef struct BinTreeNode *PBinTreeNode;   /* 结点的指针类型 */

struct BinTreeNode {
    DataType      info;           /* 数据域 */
    PBinTreeNode  llink;          /* 指向左子结点 */
    PBinTreeNode  rlink;          /* 指向右子结点 */
};

typedef struct BinTreeNode *BinTree;
typedef BinTree *PBinTree;
typedef PBinTreeNode BNode;

//十六、在二又树的链接存储中，完成以下任务:
/*
    1. 以建立如下二叉树为例，写出从终端输入数据的步骤
    2. 写出中序周游二叉树的递归函数
    3. 输出该二又树的中序周游序列

  A B D @ @ @ C E @ G @ @ F H @ @ I @ @

      A
     / \
    B   C
   /   / \
  D   E   F
       \ / \
        G H I
*/

void inOrder(PBinTreeNode p) {
    if (p == NULL) return;
    inOrder(leftChild_btree(p));  // 先遍历左子树
    visit(p);                     // 再访问根节点  
    inOrder(rightChild_btree(p)); // 最后遍历右子树
}

void preOrder(PBinTreeNode p) {
    if (p == NULL) return;
    visit(p);
    preOrder(leftChild_btree(p));
    preOrder(rightChild_btree(p));
}

void postOrder(PBinTreeNode p) {
    if (p == NULL) return;
    postOrder(leftChild_btree(p));
    postOrder(rightChild_btree(p));
    visit(p);
}

//十七、链接存储二叉树时，写出以下三个递归函数:
    /*
    1. 计算二叉树的结点个数
    2. 计算二叉树叶结点的数量       //模拟题原题
    3. 计算二叉树的高度(深度)
    */

//计算结点的个数
int num_of_nodes(PBinTreeNode p) {
    if(p == NULL) return 0;
    return (1 + num_of_nodes(p->llink) + num_of_nodes(p->rlink));
}

//计算叶结点的个数
int num_of_leaves(PBinTreeNode p) {
    if(p == NULL) return 0;
    if(p->llink == NULL && p->rlink == NULL) return 1;
    return (num_of_leaves(p->llink) + num_of_leaves(p->rlink));
}

//计算二叉树的高度
int depth(PBinTreeNode p) {
    PBinTreeNode pbtree;
    int dl, dr;
    pbtree = p;
    if(pbtree == NULL) return -1;
    dl = depth(pbtree->llink);
    dr = depth(pbtree->rlink);
    return((dl > dr ? dl:dr) + 1);
}
```

## 树（链接）
```C
/* ----------------------树（链接）---------------------- */

#define MAXNUM 20
#define null -1

typedef char DataType;  // 修改为char型

struct  ParTreeNode {
    DataType   info;    /* 结点中的元素 */
    int        parent;  /* 结点的父结点位置 */
};

struct ParTree { 
    int n;              /* 树中结点的个数 */
    struct ParTreeNode nodelist[MAXNUM];  /* 存放树中的结点 */
};

typedef struct ParTree *PParTree;        /* 树类型的指针类型 */

//十八、用父指针表示法，存储下列树，并按
    /*
    1. 先根周游的方式输出该树的所有元素。
    2. 按后根周游的方式输出所有的元素
    3. 广度优先方式输出该树的所有元素。     //模拟题原题
    */

/* 先根周游 */
void preOrder(PParTree t, int p) {
    int c;
    visit(t, p);
    c = leftChild_partree(t, p);
    while (c != null) {
        preOrder(t, c);
        c = rightSibling_partree(t, c);
    }
}

/* 后根周游 */
void postOrder(PParTree t, int p) {
    int c;
    c = leftChild_partree(t, p);
    while (c != null) {
        postOrder(t, c);
        c = rightSibling_partree(t, c);
    }
    visit(t, p);
}

/* 数组实现广度优先周游 */
void bfsOrder(PParTree t, int p) {
    int queue[MAXNUM];
    int front = 0, rear = 0;
    
    // 将根节点入队
    queue[rear++] = p;
    
    while (front < rear) {
        // 出队并访问
        int current = queue[front++];
        visit(t, current);
        
        // 将所有子节点入队
        int child = leftChild_partree(t, current);
        while (child != null) {
            queue[rear++] = child;
            child = rightSibling_partree(t, child);
        }
    }
}

void leveltree(PParTree t) {
    PSeqQueue q = createEmptyQueue_seq();
    DataType rootNode;
    rootNode.index = p;
    enQueue_seq(q, rootNode);

    while(!isEmptyQueue_seq(q))
    {
        DataType c = frontQueue_seq(q);
        deQueue_seq(q);
        visit(t, c.index);

        int child = leftChild_partree(t, c.index);
        while (child != NULL)
        {
            DataType childNode;
            childNode.index = child;
            enQueue_seq(q, childNode);
            child = rightSibling_partree(t, child);
        }
    }
    free(q);
}
```
