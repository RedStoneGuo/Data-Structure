## 11.4
1. 编写一个算法，对于输入的十进制非负整数，将它的二进制表示打印出来

![](photo/W5Q1A.png)

2. 写一个算法：PSeqStack  createEmptyStack_seq(int m)

![](photo/W5Q2A.png)


## 11.6
1. 斐波那契(Fibonocci)序列0,1,1,2,3,5,8……其中每个元素为前两之和，可递归定义为
fib(n)={n,当n=0,1时;fib(n-1)+fib(n-2),当n>2时}
给出计算 fib(n)的递归函数，并利用栈将该递归算法改成非递归函数。

![](photo/W6Q1A.png)

2. 写出 n 阶汉诺塔问题的递归函数，并利用栈，将该递归函数改写成非递归函数。

![](photo/W6Q2A.png)
![](photo/W6Q2A2.png)

[汉诺塔-CSDN](https://blog.csdn.net/m0_63703622/article/details/140999009)

[汉诺塔-知乎](https://zhuanlan.zhihu.com/p/459055987)CSDN


3. 给出中缀表达式
`(2+3*5)*3+5`
的后缀表达式并计算后缀表达式的值。(要求有过程)

```C
原始中缀表达式: (2+3*5)*3+5

中缀转后缀过程:
当前字符        栈内容          输出
(               (
2               (               2
+               + (             2
3               + (             2 3
*               * + (           2 3
5               * + (           2 3 5
)              NULL             2 3 5 * +
*               *               2 3 5 * +
3               *               2 3 5 * + 3
+               +               2 3 5 * + 3 *
5               +               2 3 5 * + 3 * 5
Fin            NULL             2 3 5 * + 3 * 5 +

后缀表达式: 2 3 5 * + 3 * 5 +

计算后缀表达式过程:
当前字符        栈内容          计算说明
2               2               压栈
3               2 3             压栈
5               2 3 5           压栈
*               2 15            3 * 5 = 15
+               17              2 + 15 = 17
3               17 3            压栈
*               51              17 * 3 = 51
5               51 5            压栈
+               56              51 + 5 = 56

最终结果: 56
```

## 11.11
1. 写出创建空队列的函数(顺序存储)、打印队列数据的函数。

![](photo/W7Q1A.png)

2. 写一算法，（不妨取名为 stackToQueue ）从一个栈创建一队列，使栈顶为队列的头，栈尾为队列的尾，算法最后要求使栈成为空栈。

![](photo/W7Q2A.png)
