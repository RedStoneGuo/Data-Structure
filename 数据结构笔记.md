@红石guo

# 第一章 绪论
## 基本概念

## 数据结构
数据间的组织方式
互相之间存在一种或多种特定关系的数据元素的集合（数据的表示）
- 基本结构：集合、线性结构、树形结构、图状（网状）结构

#### 数据类型
一个**值的集合**和定义在这个值集上的**一组操作**的总称

#### 抽象数据类型
Abstract Data Type
指一个数学模型以及定义在该模型上的一组操作

### 数据结构分类

#### 逻辑
线性结构（1，1）
树形结构（1，N）
复杂结构（N，N）
集合结构（O，O）

#### 存储
顺序、链接、散列、索引

#### 操作
队列、栈

## 算法
对特定问题求解方法和步骤的一种描述（数据的处理）

#### 算法特征
有穷性、确定性、可行性、输入、输出

### 算法效率的度量

大 O 表示法：
O(1)  O(log n)  O(n)  O(n^2)  O(2^n)

#### 渐进时间复杂度
T(n) = O(f(n))

#### 空间复杂度
S(n) = O(f(n))

# 第二章 线性表
n 个数据元素的有限序列

## 顺序表
存储结构
```C
typedef int DataType;

struct SeqList {
	int MAXNUM;
    int      n;				/* 存放线性表中元素的个数 n < MAXNUM  */
    DataType *element;	/* 存放线性表中的元素 */
};

typedef struct SeqList SeqList, *PSeqList;
```

创建空顺序表（最大长度m）
PSeqList createNullList_seq(int m)

判断为空
int isNullList_seq(PSeqList palist){
  return(palist->n == 0);
}

求元素x的下标
int locate_seq(PSeqList palist, DataType x){
  int q;
  for(q=0; q<palist->n; q++)
    if(palist->element[q] == x)
    return q;
  return -1;
}

在 palist 所指顺序表中下标p的元素之前插入元素x
int insertPre_seq(PSeqList palist, int p, DataType x)

## 单链表
存储结构
```C
typedef int DataType;

struct Node;					  /* 单链表结点类型 */
typedef  struct Node  *PNode;	  /* 结点指针类型 */
typedef  struct Node  *LinkList;  /* 单链表类型 */

struct  Node { 					  /* 单链表结点结构 */
    DataType  info;
    PNode     link;
};

LinkList llist;   //一个链表头指针
```

创建空单链表
LinkList createNullList_link(void)

判断为空
int isNullList_link(LinkList llist){
  return(llist->link==NULL);
}

求某元素x的存储位置
PNode locate_link(LinkList llist, DataType x)

在带头结点的单链表llist中下标为p的结点后插入值为x的新结点
insertPost_link(LinkList llist, PNode p, DataType x){
  PNode q=(PNode)malloc(sizeof(Struct Node));
  q->info = x;
  q->link = p->link;
  p->link = q;
}

在单链表中求p所指结点的前驱
PNode locatePre_link(LinkList)

删除第一个元素值为x的结点
int deleteV_link(LinkList llist, DataType x)

# 第三章 字符串

## 顺序表示
存储结构
```C
struct SeqString { 		/* 顺序串的类型 */
    int   n;			/*串的长度n<MAXNUM */
    char  c[MAXNUM];
};
 
typedef  struct SeqString  *PSeqString;
```

创建空顺序串
PseqString createNullStr_seq(int m)

求顺序表示的串的子串（第i个元素开始（下标[i-1]），取j个，最多取 n - i + 1 个数据）
PSeqString subStr_seq(PSeqString s, int i, int j)

## 链接表示
存储结构
```C
struct StrNode;						/* 链串的结点 */
typedef struct StrNode *PStrNode;	/* 结点指针类型 */

struct StrNode {  					/* 链串的结点结构 */
    char      c;
    PStrNode  link;
};

typedef  struct  StrNode  *LinkString;  	/* 链串的类型 */
```

创建带头结点的空链串
LinkString createNullStr_link(void)

求单链表示的串的子串（求从s所指的链串中第i个字符开始连续取j个字符所构成的子串）
LinkString subStr_link(LinkString s, int i, int j)

模式匹配（模式串p是否为目标串t的子串（求p在t中第一次出现的位置）
int index(PSeqString t, PSeqString p){
  int i = 0, j = 0;
  while(i < p->n && j < t->n)
    if(p->c[i] == t->c[j]){
      ++i; ++j;
    }
    else{
      j = j - i + 1;
      i = 0;
    }
  if(i >= p->n) return(j - p->n + 1);
  else return 0;
}

KMP 无回溯匹配
next数组计算
笔记P10

### 📘 题目

在一个长度为 `n` 的字符串 `S` 中，
要在第 `i` 个位置（即下标为 `i-1`）**插入另一个字符串**。
问：**`i` 的合法取值范围是什么？**

---

### 🔍 关键点分析

* 字符串下标从 **0 开始**。
* 长度为 `n`，意味着下标范围是：

  ```
  0, 1, 2, ..., n-1
  ```
* 插入操作：
  我们允许在每个字符“前面”或“后面”插入新的字符串。

---

### 🧩 举例说明

假设字符串 `S = "abc"`，
则：

| 插入位置编号 i | 插入的位置（下标）   | 结果举例（插入 X） |
| -------- | ----------- | ---------- |
| 1        | 下标 0 前      | `Xabc`     |
| 2        | 下标 1 前      | `aXbc`     |
| 3        | 下标 2 前      | `abXc`     |
| 4        | 下标 3 前（即尾部） | `abcX`     |

可以看到：

* 当 `n = 3` 时，合法的 `i` 值是 **1, 2, 3, 4**
* 一般情况下，合法范围是：

  ```
  1 ≤ i ≤ n + 1
  ```

---

### ✅ 答案

```
1 ≤ i ≤ n + 1
```

---

### 📘 原因总结

* 因为字符串有 `n` 个字符，但有 `n + 1` 个“间隙”可以插入新字符串：

  * 第一个字符前
  * 每两个字符之间
  * 最后一个字符后
* 所以插入位置的编号范围是 `1 ~ n+1`。

---

如果题目是 **C语言下标** 形式（从0开始），
那么对应的下标范围就是：

```
0 ≤ 下标 ≤ n
```

---

🟦 **最终答案：**

> 若按题意的 i（第 i 个位置）计：
> ✅ **1 ≤ i ≤ n + 1**
>
> 若改用下标计（即 i-1）：
> ✅ **0 ≤ i-1 ≤ n**

# 第四章 栈和队列

## 顺序栈

存储结构
```C
typedef int DataType; /* 栈中元素类型，应根据需要定义 */

struct SeqStack {	  /* 顺序栈类型定义 */
    int  t; 		  /* 栈顶位置指示 */
    DataType  s[MAXNUM];
};

typedef  struct SeqStack SeqSack, *PSeqStack;	/* 顺序栈类型和指针类型 */ 
```

栈的溢出：
上溢：添加元素数量多于MAXNUM
下溢：对空栈进行出栈操作

创建空栈
PSeqStack createEmptyStack_seq(int m)

进栈
void push_seq(PSeqStack pastack, DataType x){
  if(pastack->t >= MAXNUM - 1)
  printf("overflow\n");
  else
  {
    pastack->t = pastack->t + 1;
    pastack->s[pastack->t] = x;
  }
}

出栈
void pop_seq(PSeqStack pastack){
  if(pastack->t == -1)
  printf("underflow\n");
  else
  pastack->t = pastack->t - 1;
}

取栈顶元素
DataType top_seq(PSeqStack pastack){
  return(pastack->s[pastack->t]);
}

## 链接表示 栈
存储结构
```C
typedef int DataType;
struct  Node;					/* 单链表结点 */
typedef  struct Node  *PNode;	/* 指向结点的指针类型 */

struct  Node {                   /* 单链表结点结构 */
    DataType info;
    PNode    link;
};

struct LinkStack {               /* 链接栈类型定义 */
    PNode top;		            /* 指向栈顶结点 */
};

typedef  struct LinkStack  *PLinkStack;	 /* 链接栈类型的指针类型 */
```

创建一空链接栈
PLinkStack  createEmptyStack_link(void);

判空
int  isEmptyStack_link( PLinkStack plstack );

进栈
void push_link( PLinkStack plstack, DataType x );

出栈
void  pop_link( PLinkStack plstack );

取栈顶元素
DataType  top_link( PLinkStack plstack );

## 顺序 队列

存储结构
```C
typedef struct
{
    int x,y;            //方块的位置
     //本路径中上一方块在队列中的下标
} DataType; 

struct  SeqQueue {	/* 顺序队列类型定义 */
    int f, r;
    DataType q[MAXNUM];
};

typedef struct SeqQueue SeqQueue, *PSeqQueue;	/* 顺序队列类型和指针类型 */
```

创建空队列
PSeqQueue createEmptyQueue_seq( void );

判空
int isEmptyQueue_seq( PSeqQueue paqu );

插入
void enQueue_seq( PSeqQueue paqu, DataType x );

删除
void deQueue_seq( PSeqQueue paqu );

求队列头部元素
DataType frontQueue_seq( PSeqQueue paqu );

## 链接 队列
存储结构
```C
typedef int DataType;
struct  Node;
typedef  struct Node *PNode;

struct  Node { 		/* 结点结构 */
    DataType    info;
    PNode       link;
};

struct  LinkQueue {	/* 链接队列类型定义 */	
    PNode  f;  		/* 头指针 */
    PNode  r;  		/* 尾指针 */
};

typedef struct LinkQueue *PLinkQueue;
```

建空队列
PLinkQueue  createEmptyQueue_link( );

判空 
int  isEmptyQueue_link( PLinkQueue plqu );

进队
void  enQueue_link( PLinkQueue plqu, DataType x);

出队
void  deQueue_link( PLinkQueue plqu );

求队头元素
DataType  frontQueue_link( PLinkQueue plqu );

# 第五章 二叉树、树
满二叉树：一棵二叉树的任何结点或是树叶；或有两颗非空子树，则此二叉树称作满二叉树

完全二叉树：如果一颗二叉树至多只有最下面两层结点度数小于2，其余各层结点度数均为2，且最下面一层的结点都集中在该层最左边的位置上，则此二叉树称作完全二叉树（不一定是满二叉树）

扩充二叉树：将结点度数都变为2（树叶结点增加两个分支），分为外部和内部结点

性质：
1. 二叉树第i层上至多有 2^i 个结点(i >= 0)
2. 高度为 k 的二叉树中最多有 2^(k+1) - 1 个结点(k >= 0)
3. 对于任何一颗二叉树，如果叶结点个数为 n0，度为2的结点个数为n2，则有n0 = n2 + 1 （n0 + n1 + n2 = n1 + 2*n2 + 1）
4. 具有n个结点的完全二叉树的深度k为[log2 n]（向下取整）
5. 对于具有n个结点的完全二叉树，如果按照从上到下和从左到右的顺序对二叉树中所有结点从0开始到n-1进行编号，则对于任意的下标为i的结点，有：
    a. 如果i=0，则它是根节点，没有父结点；如果i>0，则它的父节点下标为[(i-1)/2]（向下取整）
    b. 如果2i+1 <= n-1，则下标为i的结点的左子结点的下标为2i+1；否则，下标为i的结点没有左子结点
    c. 如果2i+2 <= n-1，则下标为i的结点的右子结点的下标为2i+2；否则，下标为i的结点没有右子结点
6. 在满二叉树中，叶结点的个数比分支结点个数多1（n0 = n2 + 1）
7. 在扩充二叉树中，外部结点的个数比内部结点的个数多1
8. 对任意扩充二叉树，外部路径长度E和内部路径长度I之间满足关系：E=I+2n，其中n是内部结点个数

先根周游
void preOrder(BinTree t){
  if(t == NULL) return;
  visit(root(t));
  preOrder(leftChild(t));
  preOrder(rightChild(t));
}

中根
void inOrder(BinTree t)

后根
void postOrder(BinTree t)

广度
void levelOrder(BinTree t)

## 顺序表示 二叉树
存储结构
```C
#define  MAXNODE    20
typedef int DataType;
struct SeqBTree	{ 			/* 顺序树类型定义 */
    int       n;			/* 改造成完全二叉树后，结点的个数 */
    DataType  nodelist[MAXNODE];
};

typedef  struct SeqBTree  *PSeqBTree;
```

int root_seq(PSeqBTree t) {
    return t->nodelist[0];
}

返回下标为p的结点的父结点下标
int parent_seq(PSeqBTree t, int p) {
    return t-> nodelist[(p-1)/2];
}

返回下标为p的结点的左子结点下标
int leftChild_seq(PSeqBTree t, int p) {
    return t-> nodelist[2*p+1];
}

返回下标为p的结点的右子结点下标
int rightChild_seq(PSeqBTree t, int p) {
    return t-> nodelist[2*(p+1)];
}

## 链接表示 二叉树
存储结构
```C
typedef char DataType;

struct BinTreeNode;                         /* 二叉树中结点 */
typedef struct BinTreeNode *PBinTreeNode;   /* 结点的指针类型 */

struct BinTreeNode {
    DataType  info;                         /* 数据域 */
    PBinTreeNode  llink;                    /* 指向左子女 */
    PBinTreeNode  rlink;                    /* 指向右子女 */
};

typedef struct BinTreeNode *BinTree;
typedef BinTree *PBinTree;
```

PBinTreeNode root_btree(PBinTree t) {
    return *t;
}

PBinTreeNode leftChild_btree (PBinTreeNode p){
    return p->llink;
}

PBinTreeNode rightChild_btree (PBinTreeNode p){
    return p->rlink;
}

## 计算结点个数

计算空指针个数
n个结点，共n-1条线，2n个指针
空指针 = 2n-(n-1) = n + 1

计算结点的个数
```C
int num_of_nodes(PBinTreeNode p)
{
  if(p==NULL) return 0;
  return (1+num_of_nodes(p->llink)+num_of_nodes(p->rlink));
}
```

//计算叶结点的个数
```C
int num_of_leaves(PBinTreeNode p)
{
  if(p==NULL) return 0;
  if(p->llink==NULL && p->rlink==NULL) return 1;
  return (num_of_leaves(p->llink)+num_of_leaves(p->rlink));
}
```

//计算二叉树的高度
```C
int depth(PBinTreeNode p)
{
    PBinTreeNode pbtree;
    int dl, dr;
    pbtree = p;
    if(pbtree == NULL) return -1;
    dl = depth(pbtree->llink);
    dr = depth(pbtree->rlink);
    return((dl > dr ?dl:dr)+1);
}
```

## 哈夫曼树
带权的外部路径长度WPL 最小的扩充二叉树T

构造：贪心法
小的放左边；每构造一个二叉树都多了个内部结点◯；外部结点用▢

哈夫曼编码
左0右1，由上至下

## 树 父指针表示法
存储结构
```C
typedef int DataType;

struct ParTreeNode {
    DataType info;		/* 结点中的元素 */
    int     parent;	/* 结点的父结点位置 */
};

struct  ParTree { 
    int n;                 	/* 树中结点的个数 */
    struct ParTreeNode *nodelist;  	/* 存放树中的结点 */
};

typedef struct ParTree *PParTree;		/* 树类型的指针类型 */
```
PParTree create_Null_PParTree(int m)

PParTree create_Partree()

求右兄弟结点位置
int rightSibling_partree(PParTree t, int p) {
    int i;
    if (p >= 0 && p < t->n) {
        for (i = p+1; i <= t->n; i++)
            if (t->nodelist[i].parent == t->nodelist[p].parent)
                return i;
    }
    return -1;
}

依先根序列存储时,求最左子结点的运算可简化如下
int leftChild_partree(PParTree t, int p) {     
    if (t->nodelist[p+1].parent == p)
        return p+1;
    else
        return -1;
}

## 树 子表表示法
存储结构
```C
typedef int DataType ;

struct EdgeNode {   	/* 子表中结点的结构 */
    int             nodeposition;
    struct EdgeNode *link;
};

struct ChiTreeNode {   /* 结点表中结点的结构 */
    DataType        info;
    struct EdgeNode *children;
};

struct ChiTree {   		/* 树结构 */
    int                n; 		/* 结点个数 */
    int                root;	/* 根结点的下标 */
    struct ChiTreeNode nodelist[MAXNUM];
};

typedef struct ChiTree *PChiTree;		/* 树类型的指针类型 */
```

求右兄弟位置
int rightSibling_chitree(PChiTree t, int p)

求父结点
int parent_chitree(PChiTree t, int p)

# 第六章 集合与字典
## 集合
集合是一些互不相同元素的无序汇集

## 字典
一种特殊的集合
每个元素都有<关键码, 属性值>两部分
字典为从关键码值集合到值集合的二元关系

平均检索长度ASL = Σ 查找该元素概率 * 比较次数

## 顺序表示
存储结构
```C
typedef int KeyType ;  /* 关键码类型为int（ASCII值） */

typedef struct {
    char value;         /* 字典元素的属性字段（字符） */
    KeyType key;        /* 字典元素的关键码字段（ASCII值） */
} DicElement;

typedef struct {
    int n;              /* n<=MAXNUM，为字典中元素的个数 */
    DicElement element[MAXNUM];
} SeqDictionary;
```

顺序检索（找关键码为key的元素）
int seqSearch(SeqDictionary * pdic, KeyType key, int * position)

在字典中用二分法查找关键码为key的元素
```C
int binarySearch(SeqDictionary * pdic, KeyType key, int *position) {
    int low = 0, high = pdic->n-1, mid;

    while(low <= high) {
        mid = (low + high) / 2;                     /* 当前检索的中间位置 */
        if(pdic->element[mid].key == key) {         /* 检索成功 */
            *position = mid;  
            return TRUE;
        }
        else if (pdic->element[mid].key > key) 
            high = mid - 1;                         /* 要检索的元素在左半区 */
        else 
            low = mid + 1;                          /* 要检索的元素在右半区 */
    }
    *position = low;
    return FALSE;                                   /* 检索失败 */
}
```

最大检索长度[log2 (n+1)]（向上取整）

## 散列表示
将关键码转换为存储下标（映射）
碰撞：地址相同但关键码不同（同义词）

散列函数：地址应均匀分布在希望的地址空间中；应尽量简单

碰撞处理方法：开地址法、拉链法

## 开地址法
探查序列
$H_i = (h(key) + d_i) \% m$
其中 $m$ 为表长，$d_i$ 为增量序列，$i=1, 2, …, k(k <= m-1)$

若增量序列 $d_i = i$，则为**线性探查序列**

若 $d_i = i \times h_2(key)$，则为**双散列探查序列**

## 拉链法
为每个关键码建立一个链表，所有关键字为同义词的记录存储在同一个链表中

# 第九章 图
G = (V, E)
顶点、边

有向图、无向图

完全图：任意两个顶点之间都有边的图
n个顶点的无向完全图有 n * (n - 1) / 2 条边
n个顶点的有向完全图有 n * (n - 1) 条边

顶点的度 $D(v_1)$：与一个顶点关联的边的个数
度数和 = 2倍边数

根：某顶点有路径到达图中其他所有顶点，则该顶点为图的根，该图为有根图

连通图：若无向图中任意两个不同顶点均联通（存在路径），则该图为连通图

图的周游：
深度优先（DFS）
广度优先（BFS）

## 邻接矩阵表示 图
存储表示
```C
typedef struct {char vex;  int mark;}  VexType;

typedef float AdjType;

typedef struct {
    int n;                                 /* 图的顶点个数 */
    VexType vexs[MAXVEX];                 /*  顶点信息 */
    AdjType arcs[MAXVEX][MAXVEX];           /* 边信息 */
} GraphMatrix;
```

## 邻接表表示 图
**顶点表**+与每个顶点相关联的链式存储**边表**

## 最小生成树
生成树：周游时经过的边加上所有顶点构成图的一个连通子图，为图的生成树

最小生成树：权值最小的生成树

### prim算法：
- 设G=(V，E)是具有n个顶点(算法中用VN表示)的网络。
- T=(U，TE)为(构造中)G的最小生成树，
U是T的顶点集合，TE是T的边集合
- T初始状态是空树
  - (1) 从集合V中任取一顶点(例如取顶点v)放入集合U中，这时U={v0}，TE=NULL
  - (2) 在所有*一个顶点在集合U里，另一个顶点在集合V-U里的**边***中，找出权最小的边(u, v)(u∈U, v∈V-U)，将该边放入TE，并将顶点v加入集合U。
- 重复上述操作(2)，直到 U=V 为止。

结果TE中有**n-1条边**，T=(U,TE)就是G的一棵最小生成树

### Kruskal算法
- 设G=(V, E)是网络，最小生成树的初始状态为只有n个顶点而无边的非连通图T=(V，φ)，T中每个顶点自成为一个连通分量。
- 将集合E中的边按权递增顺序排列，从小到大依次选择顶点分别在两个连通分量中的边加入图T，则原来的两个连通分量由于该边的连接而成为一个连通分量。
- 依次类推，直到T中所有顶点都在同一个连通分量上为止，该连通分量就是G的一棵最小生成树。

## 最短路径
两顶点间路径最短的那条路径称为两个顶点间的最短路径

### Dijkstra算法
初始状态:
- 集合U中只有顶点v0，顶点v0对应的距离值为0，集合V-U中顶点vi的距离值为边(v0, vi)(i=1,2,…,n-1)的权，如果v0和vi间**无边直接相连，则vi的距离值为∞**(实际程序中可以用一个足够大的数代替)。
处理框架
- (1) 在集合V-U中选择距离值最小的顶点$v_{min}$ （中间点）加入集合U
- (2) 对集合V-U中各顶点的距离值进行修正：如果加入顶点$v_{min}$为中间顶点后，使v0到vi的距离值比原来的距离值更小，则修改vi的距离值。
- (3) 重复(1)(2)操作，直到从v0出发可以到达的所有顶点都在集合U中为止。

### Floyd算法
- 图采用**邻接矩阵**作为存储结构。把关系矩阵看成是没有经过任何中间结点，直接可以到达的每一对顶点间的最短路径的完整表示，
- 然后经过多次迭代，**每次增加一个新的结点**，在允许这个结点作为中间结点的条件下，计算**每一对**顶点间的最短路径的缩短变化，
- 直到把所有结点都考虑进去为止，结果得到每一对顶点间的最短路径。